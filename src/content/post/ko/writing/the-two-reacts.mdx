---
title: '[번역] 두 가지의 React'
description: ''
date: 2024-01-14 21:55:00
draft: false
tags:
  - react
---

import { Counter } from './the-two-reacts.tsx';

원문: https://overreacted.io/the-two-reacts/

React Core 팀의 일원이었던 [Dan Abramov](https://github.com/gaearon)가 이야기하는 현재 2가지 모습의 React입니다.

- SSR이 고도화되는 이시대의 React를 더 잘 이해할 수 있음
- 단순히 정보를 전달하는 글이 아닌 독자와의 상호작용되는 글이여서 인상적

---

당신의 화면에 무언가를 표시하고 싶다고 가정해 봅시다. 이 블로그 게시물과 같은 웹 페이지, 상호작용이 가능한 웹 앱, 또는 앱 스토어에서 다운로드할 수 있는 네이티브 앱이라도, 적어도 두 대의 장치가 관련되어야 합니다.

당신의 장치와 제 장치입니다.

이것은 제 장치에 있는 코드와 데이터로 시작됩니다. 예를 들어, 이 블로그 게시물을 제 노트북에서 파일로 편집하고 있습니다. 당신의 화면에서 이것을 보고 있다면, 이미 제 장치에서 당신의 장치로 전송되었어야 합니다. 어느 시점, 어느 장소에서, 제 코드와 데이터는 당신의 장치에 이것을 표시하도록 지시하는 HTML과 자바스크립트로 변환되었습니다.

그렇다면 이것이 React와 어떻게 관련이 있을까요? React는 UI 프로그래밍 패러다임으로, 저에게 표시할 내용(블로그 게시물, 가입 양식 또는 전체 앱)을 컴포넌트라고 하는 독립적인 부분으로 나누고, 이들을 LEGO 블록처럼 조합하게 합니다. 이미 컴포넌트에 대해 알고 좋아한다고 가정하겠습니다; react.dev에서 소개를 확인하세요.

컴포넌트는 코드이며, 그 코드는 어딘가에서 실행되어야 합니다. 하지만 잠깐—코드는 누구의 컴퓨터에서 실행되어야 할까요? 당신의 컴퓨터에서 실행되어야 할까요? 아니면 제 컴퓨터에서 실행되어야 할까요?

각 측면에 대해 한 번씩 주장해 봅시다.

## 여러분 컴퓨터에서의 실행

먼저, 컴포넌트는 당신의 컴퓨터에서 실행되어야 한다고 주장하겠습니다.

상호작용을 보여주기 위해 작은 카운터 버튼이 있습니다. 몇 번 클릭해보세요!

```tsx
<Counter />
```

<div>
  <Counter client:idle />
</div>

이 컴포넌트의 자바스크립트 코드가 이미 로드되었다고 가정한다면, 숫자는 증가할 것입니다.
누를 때마다 즉시 증가하는 것을 주목하세요. 지연이 없습니다. 서버를 기다릴 필요가
없습니다. 추가 데이터를 다운로드할 필요도 없습니다.

이것은 이 컴포넌트의 코드가 당신의 컴퓨터에서 실행되기 때문에 가능합니다:

```tsx
import { useState } from 'react';

export function Counter() {
  const [count, setCount] = useState(0);
  return (
    <button
      className="rounded-lg bg-gray-700 px-2 py-1 font-sans font-semibold text-gray-50 transition focus:ring focus:ring-gray-400 active:bg-gray-600"
      onClick={() => setCount(count + 1)}
    >
      저를 {count}번 클릭 했습니다
    </button>
  );
}
```

여기서 `count`는 클라이언트 상태의 일부로, 여러분 컴퓨터 메모리에 있는 정보이며 버튼을 누를 때마다 변경됩니다. 여러분이 버튼을 몇 번 클릭할지 모르기 때문에, 제 컴퓨터는 출력에 대한 모든 경우의 수를 대비할 수는 없습니다. 그저 초기 렌더링의 결과물("저를 0번 클릭했습니다")을 HTML로 보내는 것이 최선입니다. 하지만 그 시점 이후로는 여러분의 컴퓨터가 이 코드를 실행해야 합니다.

여러분은 이 코드를 여러분의 컴퓨터에서 실행할 필요가 없다고 주장할 수도 있습니다. 대신 제 컴퓨터에서 실행하는 것이죠. 버튼을 누를 때마다, 여러분의 컴퓨터가 제 컴퓨터에 다음 렌더링 출력을 요청할 수 있습니다. 이 동작 방식은 JavaScript 프레임워크가 생기기 이전의 웹 서버가 작동하던 방식과 흡사하지 않나요?

서버에 새로운 UI를 요청하는 것은 사용자가 약간의 지연을 예상할 때 유효합니다. 예를 들어, 링크를 클릭할 때 입니다. 사용자가 앱의 다른 장소로 이동하고 있다는 것을 알고 있으면, 기다릴 것입니다. 그러나 직접 조작(슬라이더를 드래그하는 것, 탭을 전환하는 것, 게시물 작성기에 입력하는 것, 좋아요 버튼을 클릭하는 것, 카드를 스와이프하는 것, 메뉴를 호버링하는 것, 차트를 드래그하는 것 등)은 적어도 일부 즉각적인 피드백을 제공하지 않으면 사용자에게 고장난 것처럼 느껴질 것입니다.

이 원칙은 엄밀히 기술적인 것이 아니라 일상 생활에서의 직관입니다. 예를 들어, 엘리베이터 버튼을 눌렀을 때 즉시 다음 층으로 이동할 것으로 기대하지는 않습니다. 하지만 문 손잡이를 밀 때는 손의 움직임을 직접 따라갈 것으로 기대하며, 그렇지 않으면 막힌 것처럼 느껴질 것입니다. 사실 엘리베이터 버튼에서조차 즉각적인 피드백을 기대합니다: 버튼은 손의 압력에 굴복해야 하며, 누르는 것을 인식하며 불이 켜져야 합니다.

사용자 인터페이스를 구축할 때, 적어도 일부 상호작용에 대해 보장된 낮은 지연시간과 네트워크 왕복이 없는 반응을 할 수 있어야 합니다.

React의 정신적 모델은 일종의 방정식으로 설명될 수 있습니다: UI는 상태의 함수이며, UI = f(state)입니다. 이것은 여러분의 UI 코드가 상태를 인자로 받는 단일 함수로 실제로 존재해야 한다는 것을 의미하지는 않습니다; 단지 현재 상태가 UI를 결정한다는 것을 의미합니다. 상태가 변경되면, UI는 다시 계산되어야 합니다. 상태가 여러분의 컴퓨터에 "살고 있기" 때문에, UI를 계산하는 코드(여러분의 컴포넌트들) 역시 여러분의 컴퓨터에서 실행되어야 합니다.

이 주장은 이렇게 진행됩니다.

---

이제 반대로 주장해보겠습니다—컴포넌트는 제 컴퓨터에서 실행되어야 합니다.

이 블로그의 다른 포스트에 대한 미리보기 카드입니다:

```jsx
<PostPreview slug="a-chain-reaction" />
```

체인 리액션 2452 단어 이 페이지의 컴포넌트가 해당 페이지의 단어 수를 어떻게 알고 있을까요? 네트워크 탭을 확인해보면, 추가 요청이 없음을 알 수 있습니다. 저는 단어 수를 세기 위해 GitHub에서 그 전체 블로그 포스트를 다운로드하지 않습니다. 또한 그 블로그 포스트의 내용을 이 페이지에 포함시키지도 않습니다. 단어를 세기 위해 API를 호출하지도 않습니다. 그리고 저 혼자 그 모든 단어를 세지도 않았습니다.

그렇다면 이 컴포넌트는 어떻게 작동할까요?

```js
import { readFile } from 'fs/promises';
import matter from 'gray-matter';

export async function PostPreview({ slug }) {
  const fileContent = await readFile('./public/' + slug + '/index.md', 'utf8');
  const { data, content } = matter(fileContent);
  const wordCount = content.split(' ').filter(Boolean).length;

  return (
    <section className="bg-black/5 rounded-md p-2">
      <h5 className="font-bold">
        <a href={'/' + slug} target="_blank">
          {data.title}
        </a>
      </h5>
      <i>{wordCount} 단어</i>
    </section>
  );
}
```

이 컴포넌트는 제 컴퓨터에서 실행됩니다. 파일을 읽고 싶을 때, 저는 fs.readFile로 파일을 읽습니다. 마크다운 헤더를 분석하고 싶을 때, gray-matter로 분석합니다. 단어를 세고 싶을 때, 그 텍스트를 나누고 세는 것입니다. 데이터가 있는 곳에서 바로 코드가 실행되기 때문에, 제가 추가로 할 일은 없습니다.

제 블로그의 모든 포스트와 그들의 단어 수를 나열하고 싶다고 가정해봅시다.

쉽습니다:

```tsx
<PostList />
```

모든 포스트 폴더에 대해 `<PostPreview />`를 렌더링하기만 하면 됩니다:

```js
import { readdir } from 'fs/promises';
import { PostPreview } from './post-preview';

export async function PostList() {
  const entries = await readdir('./public/', { withFileTypes: true });
  const dirs = entries.filter((entry) => entry.isDirectory());
  return (
    <div className="mb-4 flex h-72 flex-col gap-2 overflow-scroll font-sans">
      {dirs.map((dir) => (
        <PostPreview key={dir.name} slug={dir.name} />
      ))}
    </div>
  );
}
```

이 코드는 여러분의 컴퓨터에서 실행될 필요가 없었으며, 실제로 실행될 수도 없었습니다. 왜냐하면 여러분의 컴퓨터에는 제 파일이 없기 때문입니다. 이 코드가 실행된 시점을 확인해봅시다:

```html
<p className="text-purple-500 font-bold">{new Date().toString()}</p>
```

2024년 1월 5일 금요일 00:50:25 GMT+0000 (협정 세계시)

아하—그것은 바로 제가 마지막으로 제 블로그를 정적 웹 호스팅에 배포했을 때입니다! 제 컴포넌트들은 빌드 과정 중에 실행되었으므로, 제 게시물들에 대한 전체 접근 권한이 있었습니다.

제 컴포넌트들이 그들의 데이터 소스에 가깝게 실행되면, 그들은 자신의 데이터를 읽고 그 정보를 여러분의 장치로 보내기 전에 미리 처리할 수 있습니다.

이 페이지를 로드할 때, `<PostList>`나 `<PostPreview>`, fileContent나 dirs, fs나 gray-matter은 더 이상 존재하지 않았습니다. 대신 각각의 `<section>` 안에 `<a>`와 `<i>`가 있는 몇 개의 `<div>`만 존재했습니다. 여러분의 장치는 컴포넌트들이 그 UI를 계산하기 위해 사용했던 전체 원시 데이터(실제 포스트들) 대신 실제로 표시해야 할 UI만(렌더링된 포스트 제목, 링크 URL, 포스트 단어 수) 받았습니다.

이 정신적 모델로, UI는 서버 데이터의 함수이며, UI = f(data)입니다. 그 데이터는 제 장치에만 존재하기 때문에, 컴포넌트들은 제 장치에서 실행되어야 합니다.

이 주장은 이렇게 진행됩니다.

---

UI는 컴포넌트로 구성되어 있지만, 우리는 두 가지 매우 다른 비전에 대해 논쟁했습니다:

`UI = f(state)` 여기서 state는 클라이언트 측에 있으며, f는 클라이언트에서 실행됩니다. 이 접근법은 `<Counter />`와 같이 즉시 상호작용이 가능한 컴포넌트를 작성할 수 있게 합니다. (여기서, f는 초기 상태로 HTML을 생성하기 위해 서버에서도 실행될 수 있습니다.)
`UI = f(data)` 여기서 data는 서버 측에 있으며, f는 오직 서버에서만 실행됩니다. 이 접근법은 `<PostPreview />`와 같이 데이터 처리 컴포넌트를 작성할 수 있게 합니다. (여기서, f는 오직 서버에서만 실행됩니다. 빌드 시간은 "서버"로 간주됩니다.)
우리가 친숙한 편견을 떠나면, 이 두 접근법은 각각이 잘하는 것에서 매력적입니다. 불행히도, 이러한 비전들은 서로 상호 배타적으로 보입니다.

`<Counter />`와 같이 즉시 상호작용을 허용하고 싶다면, 컴포넌트를 클라이언트에서
실행해야 합니다. 하지만 `<PostPreview />`와 같은 컴포넌트는 readFile과 같은 서버
전용 API를 사용하기 때문에 원칙적으로 클라이언트에서 실행할 수 없습니다. (그것이
그들의 전체 포인트입니다! 그렇지 않다면 클라이언트에서 실행해도 괜찮을
것입니다.)

그렇다면 모든 컴포넌트를 대신 서버에서 실행한다면 어떨까요? 하지만 서버에서 `<Counter />`와 같은 컴포넌트는 초기 상태만 렌더링할 수 있습니다. 서버는 그들의 현재 상태를 알지 못하고, 그 상태를 서버와 클라이언트 간에 전달하는 것은 너무 느리며 (URL과 같이 작지 않는 이상) 항상 가능하지도 않습니다 (예를 들어, 제 블로그의 서버 코드는 배포 시에만 실행되므로 여러분은 그것에 "무언가를" 전달할 수 없습니다).

다시 한번, 우리는 두 가지 다른 React 사이에서 선택해야 하는 것처럼 보입니다:

`<Counter />`를 작성할 수 있게 하는 "클라이언트" `UI = f(state)` 패러다임.
`<PostPreview />`를 작성할 수 있게 하는 "서버" `UI = f(data)` 패러다임. 하지만 실제로, 실제 "공식"은 UI = f(data, state)에 더 가깝습니다. 데이터나 상태가 없다면, 이것은 그러한 경우에 일반화됩니다. 하지만 이상적으로, 저는 다른 추상화를 선택할 필요 없이 두 가지 경우를 모두 처리할 수 있는 프로그래밍 패러다임을 선호하며, 여러분 중 적어도 몇 명은 그것을 좋아할 것입니다.

그렇다면 해결해야 할 문제는 우리의 "f"를 매우 다른 두 프로그래밍 환

경에서 어떻게 분할할 것인가입니다. 그것이 가능한가요? 기억하세요, 우리가 얘기하는 것은 f라고 불리는 실제 함수가 아닙니다—여기에서, f는 우리의 모든 컴포넌트를 대표합니다.

우리는 React의 좋은 점을 유지하면서 컴포넌트를 여러분의 컴퓨터와 제 컴퓨터 사이에서 어떻게 나눌 수 있을까요? 두 다른 환경에서 온 컴포넌트들을 결합하고 중첩시킬 수 있을까요? 그것은 어떻게 작동할까요?

그것은 어떻게 작동해야 할까요?

이에 대해 생각해보고, 다음 번에 우리의 노트를 비교해 봅시다.
