---
title: 'Svelte Compiler는 어떻게 동작할까?'
description: ''
date: 2023-12-13 23:48:00
draft: true
tags:
  - svelte
  - compiler
---

최근 프론트엔드 분야에서 React와 Vue에 이어 Svelte가 종종 거론되고 있습니다. 흥미롭게도, 구글 검색에서 'React Vue'를 입력하면, 늘 같이 거론되었던 Angular 대신 Svelte가 상단에 추천되는 것을 볼 수 있습니다.

![231210-211816](/img/svelte-compiler-operation/231210-211816.png)

Svelte의 핵심은 **효율적인 컴파일**에 있습니다.
DOM을 조작하는 JavaScript 코드를 최적화하여 생성하는 것이죠.

React를 이해하기 위해 Virtual DOM을 알아야하는 것과 같이, Svelte를 제대로 이해하기 위해서는 Svelte Compiler가 어떻게 동작하는지 알아야 합니다.

## Svelte Compiler의 동작 방식

Svelte의 컴파일 단계는 크게 3가지 단계로 나눌 수 있습니다.

1. **Parse** (**분해**)
2. **Analyze** (**분석**)
3. **Transform** (**변환**)

[Svelte 소스코드](https://github.com/sveltejs/svelte/blob/8b60b07f42d515f926a1d04ed2597e085060155b/packages/svelte/src/compiler/index.js#L11-L43)에서 직관적으로 힌트를 얻을 수 있는데요. [버전 3 기준은 여기](https://github.com/sveltejs/svelte/blob/5e151e5efb0ec65ffdf0dde40e1d9ed9bc9feedf/src/compiler/compile/index.ts#L113-L143)
전체적인 흐름을 정리하면 아래와 같습니다.

```js
const source = fs.readFileSync('App.svelte');

// 1. Svelte 코드를 AST로 파싱하기
const ast = parse(source);

// 2. tracking references and dependencies
const analysis = analyze_component(ast);

// 3. creating code blocks and fragments
const compiled = transform_component(analysis, source);

fs.writeFileSync('App.js', compiled.js.code);
fs.writeFileSync('App.css', compiled.css.code);
```

`App.svelte` 소스코드를 읽고 일련의 과정을 거쳐서 최종적으로 `App.js`, `App.css` 파일을 생성합니다. 이 과정은 마치 마법처럼 느껴지는데요, 도대체 어떤 일이 벌어지고 있는지 한 단계씩 자세히 살펴보도록 합시다!

## 1. Svelte 코드를 AST로 파싱하기

```js
const ast = parse(source);
```

[추상 구문 트리(abstract syntax tree, AST)](https://ko.wikipedia.org/wiki/%EC%B6%94%EC%83%81_%EA%B5%AC%EB%AC%B8_%ED%8A%B8%EB%A6%AC)는 컴파일러에서 널리 쓰이는 자료구조입니다.
간단하게 설명하자면, 코드 간의 관계를 표현하기 위한 [트리 구조](https://ko.wikipedia.org/wiki/%ED%8A%B8%EB%A6%AC_%EA%B5%AC%EC%A1%B0)입니다.

`parse` 함수를 실행하면, [`Parser`](https://github.com/sveltejs/svelte/blob/8b60b07f42d515f926a1d04ed2597e085060155b/packages/svelte/src/compiler/phases/1-parse/index.js#L13) 객체가 생성되면서 AST를 반환합니다.

```js
const ast = new Parser(source).root;
```

`Parser` 생성자 내부에는 [`fragment`](https://github.com/sveltejs/svelte/blob/8b60b07f42d515f926a1d04ed2597e085060155b/packages/svelte/src/compiler/phases/1-parse/state/fragment.js) 함수를 활용해 스스로를 반복적으로 파싱하게 됩니다.

```js /fragment/#i
/** @type {ParserState} */
let state = fragment;

while (this.index < this.template.length) {
  state = state(this) || fragment;
}
```

`fragment` 내부에서는 [`element`](https://github.com/sveltejs/svelte/blob/8b60b07f42d515f926a1d04ed2597e085060155b/packages/svelte/src/compiler/phases/1-parse/state/element.js), [`tag`](https://github.com/sveltejs/svelte/blob/8b60b07f42d515f926a1d04ed2597e085060155b/packages/svelte/src/compiler/phases/1-parse/state/tag.js), [`text`](https://github.com/sveltejs/svelte/blob/8b60b07f42d515f926a1d04ed2597e085060155b/packages/svelte/src/compiler/phases/1-parse/state/text.js) 함수가 조건에 따라 실행되면서 소스코드 정보를 추출합니다.

```js /fragment/#i
import element from './element.js';
import tag from './tag.js';
import text from './text.js';

export default function fragment(parser) {
  if (parser.match('<')) {
    return element;
  }

  if (parser.match('{')) {
    return tag;
  }

  return text;
}
```

`script` 태그로 감싸진 영역은 [`read_script`](https://github.com/sveltejs/svelte/blob/8b60b07f42d515f926a1d04ed2597e085060155b/packages/svelte/src/compiler/phases/1-parse/read/script.js#L37)를 통해 파싱되는데 내부적으로는 [`acorn`](https://github.com/acornjs/acorn)를 사용합니다. `acorn`은 "**A tiny, fast JavaScript parser**"로 `webpack`, `eslint` 같이 JS 소스코드를 다뤄야하는 라이브러리에서 쓰이는 오픈소스 라이브러리입니다.

이외의 영역은 모두 Svelte Compiler 자체 파싱로직을 사용합니다.
`style` 태그를 만나면 [`read_style`](https://github.com/sveltejs/svelte/blob/8b60b07f42d515f926a1d04ed2597e085060155b/packages/svelte/src/compiler/phases/1-parse/read/style.js#L23)이 활용되고, 이외 여러 유틸을 통해서 `div` 같은 일반적인 HTML 문법을 넘어서, `{#each list as item}` `<svelte:component>` 같은 Svelte만의 문법을 해석하게 됩니다. 과정에서 유효하지 않는 코드, 웹 접근성(a11y)에 위배된 warning과 error를 기록해 알려주기도 하죠.

더 저세한 동작원리를 알고 싶다면 [JSON Parser with JavaScript](https://lihautan.com/json-parser-with-javascript/) 글을 참고 바랍니다.

최종적으로 AST 트리가 만들어진 모습을 아래 그림으로 표현할 수 있습니다.

![231213-030554](/img/svelte-compiler-operation/231213-030554.png)

더 자세한 AST 구조는 [REPL](https://svelte.dev/repl/hello-world)의 `AST output` 탭에서 확인할 수 있습니다.

## 2. 의존성 추적

```js
const analysis = analyze_component(ast);
```

- AST 바탕으로 Component 객체를 생성함
- Component의 핵심 구성요소
  - fragment
  - instance_scope, module_scope
  - vars
  - ...
- Component의 생성 과정
  - instance script와 module script AST을 순회하면서 선언되고 변경되는 모든 변수를 파악함
  - template AST에서 Fragment tree를 생성함
    - `{#if}` `{data}` `{#each}` 등 문법에 따라 다른 Fragment node가 생성됨
  - template AST을 순회하면서 사용되는 변수를 체크함
  - 확인된 정보를 통해서 최적화를 진행함
    - determine which variables or functions can be safely hoisted out of the instance function.
    - determine reactive declarations that does not need to be reactive
    - ...
  - CSS selector를 변환하여 Component Scope 안에서만 유효하도록 만듦
    - 기본적으로 `.svelte-xxx`을 붙임

## 3. 코드 블록 및 조각 생성

`Renderer` 객체 생성

- DOM Renderer
  - DOM Renderer keeps track of a list of blocks and context.
  - A Block contains code fragments for generate the create_fragment function.
  - Context tracks a list of instance variables which will be presented in the $$.ctx in the compiled output.
  - In the renderer, Svelte creates a render tree out of the Fragment tree.
  - Each node in the render tree implements the render function which generate codes that create and update the DOM for the node.
- SSR Renderer
  - provide helpers to generate template literals in the compiled output, such as add_string(str) and add_expression(node).
  - relies on different node handlers to insert strings or expressions into the final template literal.

## 4. JavaScript 및 CSS 파일 생성

```js
// Generate code
const { js, css } = renderer.render();
```

- Renderer 객체의 render 함수를 실행함으로 js, css 코드를 생성함
- 생성된 js, css 코드는 번들러에게 전달됨
- 번들러는 [`svelte-loader`](https://github.com/sveltejs/svelte-loader), [`vite-plugin-svelte`](https://github.com/sveltejs/vite-plugin-svelte/) 플러그인을 통해서 브라우저에서 사용될 번들을 생성함

## 맺으면서

- Svelte는 컴파일 단계에서 코드간의 의존성을 분석함
- 그래서 Svelte는 효율적으로 DOM을 다루는 코드를 생성
- VDOM 기반인 React, Vue 다음으로 주목을 받게됨

- 다음 글에서 컴파일된 코드가 어떻게 동작하는지 파헤쳐보자

### 참고

- https://svelte.dev/docs/svelte-compiler
- https://lihautan.com/the-svelte-compiler-handbook/
